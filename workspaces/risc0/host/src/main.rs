// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{METHOD_ELF, METHOD_ID};
use risc0_zkvm::{get_prover_server, ExecutorEnv, ExecutorImpl, ProverOpts, VerifierContext};
use std::time::Instant;
mod metrics;
use metrics::{MetricsCollector, Risc0Metrics};

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let current_dir = std::path::PathBuf::from(args[1].clone());

    let mut metrics = Risc0Metrics::default();
    let mut core_timer = MetricsCollector::new();
    let mut compress_timer = MetricsCollector::new();

    // INPUT //
    let env = ExecutorEnv::builder().build().unwrap();

    // First run executor to get cycle count and segments
    let mut exec = ExecutorImpl::from_elf(env, METHOD_ELF).unwrap();
    let session = exec.run().unwrap();
    metrics.cycles = session.user_cycles;
    metrics.num_segments = session.segments.len();

    // Setup the prover
    let opts = ProverOpts::default();
    let prover = get_prover_server(&opts).unwrap();

    // Generate core proof
    core_timer.start_timing();
    let ctx = VerifierContext::default();
    let info = prover.prove_session(&ctx, &session).unwrap();
    metrics.core_prove_duration = core_timer.elapsed().unwrap();

    let receipt = info.receipt;
    let composite_receipt = receipt.inner.composite().unwrap();
    metrics.core_proof_size = composite_receipt
        .segments
        .iter()
        .map(|s| s.seal.len() * 4)
        .sum();

    // Verify core proof
    core_timer.start_timing();
    receipt.verify(METHOD_ID).unwrap();
    metrics.core_verify_duration = core_timer.elapsed().unwrap();

    // Generate compressed/recursive proof
    compress_timer.start_timing();
    let compressed_proof = prover.compress(&ProverOpts::succinct(), &receipt).unwrap();
    metrics.compress_prove_duration = compress_timer.elapsed().unwrap();

    // Verify compressed proof
    compress_timer.start_timing();
    compressed_proof.verify(METHOD_ID).unwrap();
    metrics.compress_verify_duration = compress_timer.elapsed().unwrap();

    // Get compressed proof size
    let succinct_receipt = compressed_proof.inner.succinct().unwrap();
    metrics.recursive_proof_size = succinct_receipt.seal.len() * 4;

    // OUTPUT //

    // Save proof artifacts
    std::fs::create_dir_all(current_dir.join("proof_data/risc0"))
        .expect("Failed to create proof_data/risc0");
    let serialized = bincode::serialize(&receipt).unwrap();
    std::fs::write(
        &current_dir.join("proof_data/risc0/risc0.proof"),
        &serialized,
    )
    .expect("Failed to create Risc0 proof file");
    std::fs::write(
        &current_dir.join("proof_data/risc0/risc0.imageid"),
        &convert(&METHOD_ID),
    )
    .expect("Failed to create Risc0 Image ID file");
    std::fs::write(
        &current_dir.join("proof_data/risc0/risc0.pub"),
        &receipt.journal,
    )
    .expect("Failed to create Risc0 public input file");

    // Save metrics
    metrics::write_metrics(&metrics, &current_dir.join("proof_data/risc0"))
        .expect("Failed to save metrics");
}

pub fn convert(data: &[u32; 8]) -> [u8; 32] {
    let mut res = [0; 32];
    for i in 0..8 {
        res[4 * i..4 * (i + 1)].copy_from_slice(&data[i].to_le_bytes());
    }
    res
}
